### 浏览器渲染流程

* 渲染进程将HTML内容转换为**DOM树**结构
* 渲染引擎将css样式表转化为浏览器可以理解的**styleSheets**，计算出DOM节点的样式
* 创建**布局树**，并计算元素的布局信息
* 对布局树进行分层，并生成**分层树**
* 为每个图层生成**绘制列表**，并提交到合成线程
* 合成线程将图层分成**图块**，并在**光栅化线程池**中将图块转换成位图
* 合成线程发送绘制图块命令**DrawQuad**给浏览器进程
* 浏览器进程根据DrawQuad消息**生成页面**，并**显示**到显示器上



### 重排
更新了元素的几何属性（宽度，高度等），就会产生重排
重排需要更新完证的渲染流水线，所以开销最大的

### 重绘
更新了元素的绘制属性（颜色等）就会产生重绘
重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一下

### 合成
更改了不要布局也不需要绘制的属性（例：使用CSS的transform来实现动画效果），就会产生合成
相对于重绘和重排，合成能大大提高绘制效率

### 减少重绘重排的方法
* 使用class操作样式，而不是使用style频繁的操作style
* 避免使用table布局
* 批量dom操作，例如createDocumentFragment,或者使用框架
* 对window resize进行节流
* 对dom属性的读写分离
* will-change:transform 做优化